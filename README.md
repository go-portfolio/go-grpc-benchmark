# Сгенерировать Go код из proto
```bash
$ protoc \
  --go_out=. --go_opt=paths=source_relative \
  --go-grpc_out=. --go-grpc_opt=paths=source_relative \
  proto/benchmark.proto
```

# Запустить сервер
go run cmd/server/main.go

# Запустить клиент бенчмарка
go run cmd/client/main.go

✅ Особенности сервера с debug:

Запуск с флагом:
```bash
go run cmd/server/main.go -debug
```

Особенности отлаживаемого клиента:
Флаг -debug
```bash
go run cmd/client/main.go -debug
```

Вот как можно кратко описать этот момент в README:

---

### Отладка в VS Code

Для отладки сервера и клиента используется Delve через `launch.json`.

* **Флаги (`-debug`, `--verbose`)** передаются в `main` только для управления поведением программы (например, включение подробного логирования).
* **Отладчик работает без флагов** — достаточно поставить точки останова в коде.
* Пример запуска из VS Code:

```json
"program": "${workspaceFolder}/cmd/server",
"args": ["-debug"]
```

Флаги здесь не обязательны для работы отладчика, а служат для включения дополнительного вывода или специальных режимов работы приложения.


## CLI-флаги

При запуске клиента и сервера поддерживаются следующие флаги:

Флаг	Описание
-debug	Включает режим отладки. Все вызовы logDebug выводят отладочные сообщения, полезные при разработке.
-verbose	Включает подробное логирование работы клиента. Все вызовы logVerbose показывают информацию о каждом RPC, ответах и ошибках.

Примеры запуска:

### Сервер с режимом отладки
go run cmd/server/main.go -debug

### Клиент с подробным логированием
go run cmd/client/main.go -verbose


Рекомендуется использовать -debug при разработке новых возможностей, а -verbose для анализа поведения клиента во время тестов и бенчмарков.

## gRPC Benchmark Server Methods

Ниже перечислены все методы сервера и их функциональность.

| Метод                  | Тип RPC                  | Описание                                                                 |
|------------------------|--------------------------|--------------------------------------------------------------------------|
| `Ping`                 | Unary                    | Клиент отправляет одно сообщение, сервер возвращает его обратно (эхо). Используется для базового тестирования задержки и успешности RPC. |
| `Stats`                | Unary                    | Клиент запрашивает статистику работы сервера. Сервер возвращает общее количество успешных запросов и среднее время обработки. Позволяет мониторить нагрузку и производительность. |
| `PushNotifications`    | Server Streaming         | Клиент отправляет один запрос, сервер открывает поток и отправляет несколько сообщений (например, уведомления). Используется для имитации вещания или уведомлений от сервера. |
| `AggregatePing`        | Client Streaming         | Клиент открывает поток и отправляет несколько сообщений подряд. Сервер собирает все сообщения и возвращает один агрегированный ответ. Используется для тестирования пропускной способности и объединения запросов. |
| `StreamPing`           | Bidirectional Streaming  | Клиент и сервер открывают двунаправленный поток. Клиент отправляет сообщения, сервер сразу отвечает. Используется для имитации чата или обмена данными в реальном времени. |

## Отладка проекта

В репозитории настроен `launch.json` для VS Code с поддержкой Go.  
Доступны следующие конфигурации:

- **Debug Server** — запуск и отладка сервера (`cmd/server`) с флагами `-debug -verbose`.  
- **Debug Client** — запуск и отладка клиента (`cmd/client`) с теми же флагами.  
- **Debug Server + Client** — одновременный запуск и отладка сервера и клиента.  

Используйте эти конфигурации через меню *Run and Debug* в VS Code.

## Создание сертификатов для TLS / mTLS

### 1️⃣ Создаём CA (центр сертификации)
1. Перейдите в папку ``cmd/server/certs``
2. Выполните

```bash
# Приватный ключ CA
openssl genrsa -out ca.key 4096

# Сертификат CA (публичный)
openssl req -x509 -new -nodes -key ca.key -sha256 -days 3650 -subj "/CN=Test-CA" -out ca.crt
```
3. Скопируйте полученные файлы `ca.crt` и `ca.key` в папку ``cmd/client/certs``


### Генерация серверного сертификата с SAN
1. Перейдите в папку ``cmd/server/certs``
2. Выполните команды
```bash
# Приватный ключ сервера
openssl genrsa -out server.key 4096

# CSR с конфигом
openssl req -new -key server.key -out server.csr -config server-openssl.cnf

# Подписать у CA с расширениями
openssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial \
  -out server.crt -days 365 -extensions v3_req -extfile server-openssl.cnf

```

### Генерация клиентского сертификата с SAN
1. Перейдите в папку ``cmd/client/certs``
2. Выполните команды
```bash
# Приватный ключ клиента
openssl genrsa -out client.key 4096

# CSR с конфигом
openssl req -new -key client.key -out client.csr -config client-openssl.cnf

# Подписать у CA с расширениями
openssl x509 -req -in client.csr -CA ca.crt -CAkey ca.key -CAcreateserial \
  -out client.crt -days 365 -extensions v3_req -extfile client-openssl.cnf

```


## План по добавлению в проект возможностей

## Дополнительные возможности

- **TLS / безопасность**
  - Поддержка TLS для защищённого соединения.
  - Возможность клиентской аутентификации с сертификатами.

- **Метрики и мониторинг**
  - Экспорт статистики сервера через Prometheus.
  - Отслеживание количества запросов, средней задержки, RPS и ошибок.
  - Возможность визуализации через Grafana.

- **Логирование и трассировка**
  - Поддержка `--debug` для отладочных сообщений (`logDebug`).
  - Поддержка `--verbose` для подробного логирования RPC-вызовов (`logVerbose`).
  - Возможность интеграции с OpenTelemetry для трассировки.

- **Тестирование нагрузки**
  - Настраиваемое число параллельных горутин и запросов.
  - Замер latency distribution: p50, p90, p99.
  - Сценарии нагрузки: легкая, пиковая, постоянная.

- **Интерактивный CLI-клиент**
  - Ввод команд: `ping`, `streamping`, `stats`.
  - Визуализация результатов в терминале (таблицы, графики).

- **Симуляция различных задержек и ошибок**
  - 2% запросов могут падать для демонстрации обработки ошибок.
  - Случайная задержка обработки запросов (1–5 мс).

