## Сгенерировать Go код из proto
```bash
$ protoc \
  --go_out=. --go_opt=paths=source_relative \
  --go-grpc_out=. --go-grpc_opt=paths=source_relative \
  proto/benchmark.proto
```

## Запустить сервер
go run cmd/server/main.go

## Запустить клиент бенчмарка
go run cmd/client/main.go

✅ Особенности сервера с debug:

Запуск с флагом:
```bash
go run cmd/server/main.go -debug -verbose 
```


## ⚙️ Отладка в VS Code (`launch.json`)

Для удобства разработки и тестирования проекта предусмотрены конфигурации отладки в Visual Studio Code.  
Файл `launch.json` содержит настройки для запуска сервера и клиента gRPC-бенчмарка.

* **Флаги (`-debug`, `--verbose`)** передаются в `main` только для управления поведением программы (например, включение подробного логирования).
* **Отладчик работает без флагов** — достаточно поставить точки останова в коде.
* Пример запуска из VS Code:

| Конфигурация              | Назначение                                        | Аргументы         |
| ------------------------- | ------------------------------------------------- | ----------------- |
| **Debug Server**          | Запускает gRPC сервер в режиме отладки            | `-debug -verbose` |
| **Debug Client**          | Запускает клиента для тестирования или бенчмарков | `-debug -verbose` |
| **Debug Server + Client** | Одновременный запуск обеих конфигураций           | —                 |


Флаги здесь не обязательны для работы отладчика, а служат для включения дополнительного вывода или специальных режимов работы приложения.


## CLI-флаги

| Флаг       | Описание                                                                                                                      |
| ---------- | ----------------------------------------------------------------------------------------------------------------------------- |
| `-debug`   | Включает режим отладки. Все вызовы `logDebug` выводят отладочные сообщения, полезные при разработке.                          |
| `-verbose` | Включает подробное логирование работы клиента. Все вызовы `logVerbose` показывают информацию о каждом RPC, ответах и ошибках. |

Примеры запуска:

### Сервер с режимом отладки
go run cmd/server/main.go -debug

### Клиент с подробным логированием
go run cmd/client/main.go -verbose


Рекомендуется использовать -debug при разработке новых возможностей, а -verbose для анализа поведения клиента во время тестов и бенчмарков.

## gRPC Benchmark Server Methods

Ниже перечислены все методы сервера и их функциональность.

| Метод                  | Тип RPC                  | Описание                                                                 |
|------------------------|--------------------------|--------------------------------------------------------------------------|
| `Ping`                 | Unary                    | Клиент отправляет одно сообщение, сервер возвращает его обратно (эхо). Используется для базового тестирования задержки и успешности RPC. |
| `Stats`                | Unary                    | Клиент запрашивает статистику работы сервера. Сервер возвращает общее количество успешных запросов и среднее время обработки. Позволяет мониторить нагрузку и производительность. |
| `PushNotifications`    | Server Streaming         | Клиент отправляет один запрос, сервер открывает поток и отправляет несколько сообщений (например, уведомления). Используется для имитации вещания или уведомлений от сервера. |
| `AggregatePing`        | Client Streaming         | Клиент открывает поток и отправляет несколько сообщений подряд. Сервер собирает все сообщения и возвращает один агрегированный ответ. Используется для тестирования пропускной способности и объединения запросов. |
| `StreamPing`           | Bidirectional Streaming  | Клиент и сервер открывают двунаправленный поток. Клиент отправляет сообщения, сервер сразу отвечает. Используется для имитации чата или обмена данными в реальном времени. |


## Создание сертификатов для TLS / mTLS

### 1️⃣ Создаём CA (центр сертификации)
1. Перейдите в папку ``cmd/server/certs``
2. Выполните

```bash
# Приватный ключ CA
openssl genrsa -out ca.key 4096

# Сертификат CA (публичный)
openssl req -x509 -new -nodes -key ca.key -sha256 -days 3650 -subj "/CN=Test-CA" -out ca.crt
```
3. Скопируйте полученные файлы `ca.crt` и `ca.key` в папку ``cmd/client/certs``


### Генерация серверного сертификата с SAN
1. Перейдите в папку ``cmd/server/certs``
2. Выполните команды
```bash
# Приватный ключ сервера
openssl genrsa -out server.key 4096

# CSR с конфигом
openssl req -new -key server.key -out server.csr -config server-openssl.cnf

# Подписать у CA с расширениями
openssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial \
  -out server.crt -days 365 -extensions v3_req -extfile server-openssl.cnf

```

### Генерация клиентского сертификата с SAN
1. Перейдите в папку ``cmd/client/certs``
2. Выполните команды
```bash
# Приватный ключ клиента
openssl genrsa -out client.key 4096

# CSR с конфигом
openssl req -new -key client.key -out client.csr -config client-openssl.cnf

# Подписать у CA с расширениями
openssl x509 -req -in client.csr -CA ca.crt -CAkey ca.key -CAcreateserial \
  -out client.crt -days 365 -extensions v3_req -extfile client-openssl.cnf

```

## Load Testing (Нагрузочное тестирование)

Клиент поддерживает тестирование нагрузки для gRPC сервиса с замером **latency** (p50, p90, p99) и различными сценариями.

### Параметры

- `requests` – количество запросов/сообщений  
- `concurrency` – число параллельных горутин  
- `scenario` – сценарий нагрузки: `light`, `peak`, `constant`  

**Сценарии нагрузки:**

- `light` – лёгкая нагрузка, пауза между запросами (~100 мс)  
- `peak` – пиковая нагрузка, короткая случайная пауза (~0–10 мс)  
- `constant` – постоянная нагрузка, без пауз  

### Пример использования

```go
// Настройки нагрузки
requests := 1000
concurrency := 50
scenario := client.ScenarioPeak

client.UnaryPing(c, requests, concurrency, scenario)
client.StreamPing(c, 100, concurrency, scenario)
client.PushNotifications(c, "start", concurrency, scenario)
client.AggregatePing(c, 50, concurrency, scenario)
```

## Prometheus метрики

Наш gRPC сервер интегрирован с Prometheus и собирает следующие метрики:

### 1. Метрики gRPC запросов

| Метрика | Тип | Описание | Лейблы |
|---------|-----|----------|--------|
| `grpc_rpc_requests_total` | Counter | Общее количество gRPC запросов | `method` – имя метода, `status` – `success` или `error` |
| `grpc_rpc_latency_seconds` | Histogram | Распределение латентности gRPC запросов (секунды) | `method` – имя метода |
| `grpc_rpc_request_size_bytes` | Histogram | Размер gRPC запросов в байтах | `method` – имя метода |
| `grpc_rpc_response_size_bytes` | Histogram | Размер gRPC ответов в байтах | `method` – имя метода |

> Эти метрики собираются через кастомные интерсепторы `PrometheusUnaryInterceptor` и `PrometheusStreamInterceptor` и автоматически регистрируются при старте сервера.

---

### 2. Доступ к метрикам

Метрики доступны по HTTP эндпоинту:
```
http://localhost:9090/metrics
```

- Данные можно использовать напрямую в Prometheus или для визуализации через Grafana.
- Метрики обновляются в реальном времени при обработке запросов gRPC.


## OpenTelemetry (Tracing)

Сервер интегрирован с **OpenTelemetry** для распределённой трассировки gRPC запросов. Используется **экспортер Jaeger**, что позволяет визуализировать трассы и измерять latency каждого запроса.

### 1. Настройка OpenTelemetry

- Экспортер: **Jaeger Collector**
- Адрес по умолчанию: `http://localhost:14268/api/traces`
- Сервис зарегистрирован как: `grpc-benchmark-server`
- Каждый RPC вызов автоматически создаёт **span** с информацией о методе, статусе и времени выполнения.


Для просмотра трасс используйте Jaeger UI:
```
http://localhost:16686
```


